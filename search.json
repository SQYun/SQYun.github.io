[{"title":"前端IndexedDB 存储方案","url":"/2018/05/30/前端 indexedDB 存储方案/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nIndexedDB 是一种使用浏览器存储大量数据的方法.它创造的数据可以被查询，并且可以离线使用. IndexedDB对于那些需要存储大量数据，或者是需要离线使用的程序是非常有效的解决方法. --- MDN\n<!-- more -->\n<The rest of contents | 余下全文>\n我们都知道在前端开发当中,有时会因为某些需求,要将一些数据存储在前端本地当中.比如说:为了优化性能,将一些常用的数据存在本地,这样以后需要的时候直接从本地拿,不需要再向后端进行请求.还有就是为了防止CSRF攻击,后端给前端一个token,前端就需要将这个token存在本地.之后每次请求都需要带上这个token.等等不一而足.\n\n  而这些需求就不油避免的造就一个前端的发展方向--前端存储\n\n  在前端的'上古时代'里,我们前端想要存储数据,只有一种方式,那就是Cookie.但是Cookie虽然可以做前端存储方案,但是却也有着很多局限性.首先它的存储空间大小只有4K,其次它的存储有效时间有限制,然后存在Cookie中的数据,在你每次进行请求的时候都会将它带上.使得每次的请求数据都会无意义的增大.最后,也是最重要的一点.Cookie设计之初就不是就是让我们前端存数据用的.它只是为了让网站验证用户身份用的.至于Cookie的本地存储功能只是它的一个手段而已.关于这点你们可以看下我的另外一篇文章---在HTML5的时代,重新认识Cookie\n\n  综上所述,使用Cookie作为前端存储有这许多缺点,所以经过前端社区的不断努力,在HTML5中有了真正的前端存储方案Web Storage.它分为两种,一种是永久存储的localStorage,一种是会话期间存储的sessionStorage.对比Cookie,Web Storage的优势很明显:\n\n存储空间更大,有5M大小\n在浏览器发送请求是不会带上web Storage里的数据\n更加友好的API\n可以做永久存储(localStorage).\n  这一切看起来很完美,但是随着前端的不断发展,web Storage也有了一些不太合适的地方:\n\n随着web应用程序的不断发展,5M的存储大小对于一些大型的web应用程序来说有些不够\nweb Storage只能存储string类型的数据.对于Object类型的数据只能先用JSON.stringify()转换一下在存储.\n  基于上述原因,前端社区又提出了浏览器数据库存储这个概念.而Web SQL Database和indexedDB(索引数据库)是对这个概念的实现.其中Web SQL Database在目前来说基本已经被放弃.所以目前主流的浏览器数据库的实现就是indexedDB(索引数据库).也就是我们要介绍的 新一代的前端存储方案--indexedDB\n\n什么是 indexedDB\n---------------------------------------\nIndexedDB 是一种使用浏览器存储大量数据的方法.它创造的数据可以被查询，并且可以离线使用. IndexedDB对于那些需要存储大量数据，或者是需要离线使用的程序是非常有效的解决方法. --- MDN\n  上面是MDN上对于IndexedDB的介绍.其简单而言,indexedDB就是一个基于事务操作的key-value型数前端数据库.其API大多是异步的\n\nindexedDB的使用\n---------------------------------------\n创建一个indexedDB数据库\n```const request = indexedDB.open('myDatabase', 1);\nrequest.addEventListener('success', e => {\n    console.log('连接数据库成功');\n});\nrequest.addEventListener('error', e => {\n    console.log('连接数据库失败');\n});\n```\n  在上面代码中我们使用indexedDB.open()创建一个indexedDB数据库.open()方法接受可以接受两个参数.第一个是数据库名,第二个是数据库的版本号.同时返回一个IDBOpenDBRequest对象用于操作数据库.其中对于open()的第一个参数数据库名,open()会先去查找本地是否已有这个数据库,如果有则直接将这个数据库返回,如果没有,则先创建这个数据库,再返回.对于第二个参数版本号,则是一个可选参数,如果不传,默认为1.但如果传入就必须是一个整数.\n\n  在通过对indexedDB.open()方法拿到一个数据库对象IDBOpenDBRequest我们可以通过监听这个对象的success事件和error事件来执行相应的操作.\n\n创建一个对象仓库\n---------------------------------------\n  再有了一个数据库之后,我们获取就想要去存储数据了,但是单只有数据库还不够,我们还需要有对象仓库(object store).对象仓库(object store)是indexedDB数据库的基础,其类似于MySQL中表的概念.\n\n要创建一个对象仓库必须在upgradeneeded事件中,而upgradeneeded事件只会在版本号更新的时候触发.这是因为indexedDB API中不允许数据库中的数据仓库在同一版本中发生变化\n```const request = indexedDB.open('myDatabase', 2);\nrequest.addEventListener('upgradeneeded', e => {\n    const db = e.target.result;\n    const store = db.createObjectStore('Users', {\n        keyPath: 'userId',\n        autoIncrement: false\n    });\n    console.log('创建对象仓库成功');\n});\n```\n  在上述代码中我们监听upgradeneeded事件,并在这个事件触发时使用createObjectStore()方法创建了一个对象仓库.createObjectStore()方法接受两个参数,第一个是对象仓库的名字,在同一数据库中,仓库名不能重复.第二个是可选参数.用于指定数据的主键,以及是否自增主键.\n\n创建事务\n---------------------------------------\n\n  OK现在我们有了数据库和对象仓库了,我们是否就可以存储数据了了.很抱歉,还是不行.我们还差最后一样东西----事务.\n\n什么是事务\n---------------------------------------\n\n一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的\n  上面是维基百科上对数据库事务的解释.简单来说事务就是用来保证数据库操作要么全部成功,要么全部失败的一个限制.比如,在修改多条数据时,前面几条已经成功了.,在中间的某一条是失败了.那么在这时,如果是基于事务的数据库操作,那么这时数据库就应该重置前面数据的修改,放弃后面的数据修改.直接返回错误,一条数据也不修改.\n<pre>const request = indexedDB.open('myDatabase', 3);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n});\n</pre>\n上述代码中我们使用transaction()来创建一个事务.transaction()接受两个参数,第一个是你要操作的对象仓库名称,第二个是你创建的事务模式.传入 readonly时只能对对象仓库进行读操作,无法写操作.可以传入readwrite进行读写操作.\n\n操作数据\n---------------------------------------\n  好了现在有了数据库,对象仓库,事务之后我们终于可以存储数据了.\n\nadd() : 增加数据。接收一个参数，为需要保存到对象仓库中的对象。\nput() : 增加或修改数据。接收一个参数，为需要保存到对象仓库中的对象。\nget() : 获取数据。接收一个参数，为需要获取数据的主键值。\ndelete() : 删除数据。接收一个参数，为需要获取数据的主键值。\nadd 和 put 的作用类似，区别在于 put 保存数据时，如果该数据的主键在数据库中已经有相同主键的时候，则会修改数据库中对应主键的对象，而使用 add 保存数据，如果该主键已经存在，则保存失败。\n\n\n添加数据\n---------------------------------------\n```\nconst request = indexedDB.open('myDatabase', 3);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n    const store = tx.objectStore('Users');\n    const reqAdd = store.add({\n        'userId': 1,\n        'userName': '李白',\n        'age': 24\n    });\n    reqAdd.addEventListener('success', e => {\n        console.log('保存成功')\n    })\n});\n```\n\n\n获取数据\n---------------------------------------\n\n```\nconst request = indexedDB.open('myDatabase', 3);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n    const store = tx.objectStore('Users');\n    const reqGet = store.get(1);\n    reqGet.addEventListener('success', e => {\n        console.log(this.result.userName);\n    })\n});\n```\n\n\n删除数据\n---------------------------------------\n```\nconst request = indexedDB.open('myDatabase', 3);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n    const store = tx.objectStore('Users');\n    const reqDelete = store.delete(1);\n    reqDelete.addEventListener('success', e => {\n        console.log('删除数据成功');\n    })\n});\n```\n使用游标\n---------------------------------------\n  在上面当中我们使用get()方法传入一个主键来获取数据,但是这样只能够获取到一条数据.如果我们想要获取多条数据了怎么办.我们可以使用游标,来获取一个区间内的数据.\n\n  要使用游标,我们需要使用对象仓库上的openCursor()方法创建币打开.openCursor()方法接受两个参数.\n```\nopenCursor(range?: IDBKeyRange | number | string | Date | IDBArrayKey, direction?: IDBCursorDirection): IDBRequest;\n```\n  第一个是范围,范围可以是一个IDBKeyRange对象.用以下方式创建.\n```\nvar boundRange = IDBKeyRange.bound(1, 10, false, false);\nvar onlyRange = IDBKeyRange.only(1);\nvar lowerRange = IDBKeyRange.lowerBound(1, false);\nvar upperRange = IDBKeyRange.upperBound(10, false);\n```\n  第二个参数是方向.主要有一下几种\n\nnext : 游标中的数据按主键值升序排列，主键值相等的数据都被读取\nnextunique : 游标中的数据按主键值升序排列，主键值相等只读取第一条数据\nprev : 游标中的数据按主键值降序排列，主键值相等的数据都被读取\nprevunique : 游标中的数据按主键值降序排列，主键值相等只读取第一条数据\n  下面让我们来看一个完整的例子\n```\nconst request = indexedDB.open('myDatabase', 4);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n    const store = tx.objectStore('Users');\n    const range = IDBKeyRange.bound(1, 10);\n    const req = store.openCursor(range, 'next');\n    req.addEventListener('success', e => {\n        const cursor = this.result;\n        if (cursor) {\n            console.log(cursor.value.userName);\n            cursor.continue();\n        } else {\n            console.log('检索结束');\n        }\n    })\n});\n```\n  在上面的代码中如果检索到符合条件的数据时,我们可以:\n\n使用cursor.value拿到数据.\n使用cursor.updata()更新数据.\n使用cursor.delete()删除数据.\n使用cursor.continue()读取下一条数据.\n\n\n索引\n---------------------------------------\n\n  在上面代码中我们获取数据都是用的主键.但是,在很多情况下我们并不知道我们需要数据的主键是什么,我们知道一个大概的条件.比如说年龄大于20岁的用户.这个时候我们就需要用到索引.以便有条件的查找.\n\n创建索引\n---------------------------------------\n\n  我们使用对象仓库的createIndex()方法来创建一个索引.\n\n```\ncreateIndex(name: string, keyPath: string | string[], optionalParameters?: IDBIndexParameters): IDBIndex;\n```\ncreateIndex()方法接收三个参数:\n\n第一个参数name是索引名,不能重复.\n第二个参数keyPath是你要在存储对象上的那个属性上建立索引,可以是一个单个的key值,也可以是一个包含key值集合的数组.\n第三个参数optionalParameters是一个可选的对象参数{unique, multiEntry}\nunique: 用来指定索引值是否可以重复,为true代表不能相同,为false时代表可以相同\nmultiEntry: 当第二个参数keyPath为一个数组时.如果multiEntry是true,则会以数组中的每个元素建立一条索引.如果是false,则以整个数组为keyPath值,添加一条索引.\n  下面让我们来看一个完整的例子,我们建立一条用户年龄的索引.\n```\nconst request = indexedDB.open('myDatabase', 5);\nrequest.addEventListener('upgradeneeded', e => {\n    const db = e.target.result;\n    const store = db.createObjectStore('Users', {\n        keyPath: 'userId',\n        autoIncrement: false\n    });\n    const idx = store.createIndex('ageIndex', 'age', {\n        unique: false\n    })\n});\n```\n  这样我们就创建了一条索引.\n\n创建索引\n---------------------------------------\n  这在创建了一条索引之后我们就可以来使用它了.我们使用对象仓库上的index方法,通过传入一个索引名.来拿到一个索引对象.\n\n```\nconst index = store.index('ageIndex');\n```\n\n  然后我们就可以使用这个索引了.比如说我们要拿到年龄在20岁以上的数据,升序排列.\n\n```\nconst request = indexedDB.open('myDatabase', 4);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n    const store = tx.objectStore('Users');\n    const index = store.index('ageIndex');\n    const req = index.openCursor(IDBKeyRange.lowerBound(20), 'next');\n    req.addEventListener('success', e => {\n        const cursor = e.target.result;\n        if (cursor) {\n            console.log(cursor.value.age);\n            cursor.continue();\n        } else {\n            console.log('检索结束');\n        }\n    })\n});\n```\nindexedDB 的兼容性\n---------------------------------------\n        \n上面是我对indexedDB一些粗浅的总结,希望对大家有所帮助.如果文中有何不当之处请予以斧正,谢谢.\n\n参考资料:\n\nMDN---IndexedDB\nMDN---基本概念\nHTML5 进阶系列：indexedDB 数据库","tags":["js"],"categories":["前端"]},{"title":"测试","url":"/2018/05/29/第一天/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n测试\n<!-- more -->\n<The rest of contents | 余下全文>\n测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试","tags":["test"],"categories":["test"]}]